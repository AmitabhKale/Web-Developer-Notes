# Advanced Topics in TypeScript

- [Generics](#generics)
  - [Generics with arrow functions in tsx](#generics-in-arrow-functions--tsx-files)
  - [Generics with Constraint](#generics-with-constraints)
  - [Generics Class Example](#generic-class-example)
- [Null & Undefined](#null--undefined)
  - [Types](#types)
  - [Nullish Coalesence](#nullish-coalescence)
  - [Non Null Assertion Operator](#non-null-assertion-operator)
- [Type Narrowing in Detail](#type-narrowing-in-detail)
  - [Typeof Guards](#typeof-guards)
  - [Truthiness Guards](#truthiness-guards)
  - [Equality Narrowing](#equality-narrowing)
  - [in Operator](#in-operator-narrowing)
  - [instanceof Narrowing](#instanceof-narrowing)
  - [Type Predicates](#type-predicates)
- [Utility Types](#utility-types)
  - [Partial](#partial)

---

## Generics

Generics allows us to define reusable functions and classes that work with multiple types rather than a single type.

```ts
function identity<Type>(arg: Type): Type {
  return arg;
}
```

In Below Example, function identity can take number as a input and return number,Same if we pass the string it will return string.

```ts
function identity<T>(id: T): T {
  return id;
}

console.log(identity<number>(123));
console.log(identity<string>("John"));
```

```ts
function getRandomElement<T>(list: T[]): T {
  const randIdx = Math.floor(Math.random() * list.length);
  return list[randIdx];
}

console.log(getRandomElement<string>(["a", "b", "c"]));
getRandomElement<number>([5, 6, 21, 354, 567, 234, 654]);
getRandomElement([1, 2, 3, 4]);
```

### Generics in Arrow Functions & .tsx files

While working with react, jsx may confuse with angle brackets.

```tsx
const CartItem = <T,>(item: T) => item;
```

Refernce: <a href="https://stackoverflow.com/questions/32308370/what-is-the-syntax-for-typescript-arrow-functions-with-generics">Stack Overflow Post about genrics in tsx</a>

### Genrics with Multiple Types

```ts
function merge<T, U>(obj1: T, obj2: U) {
  return {
    ...obj1,
    ...obj2,
  };
}

const comboObj = merge({ name: "John" }, { pets: ["blue"] });
console.log(comboObj);
```

### Generics with Constraints

```ts
// Generics With Constraints:
function merge<T extends object, U extends object>(object1: T, object2: U) {
  return {
    ...object1,
    ...object2,
  };
}

const comboObj = merge({ name: "colt" }, { pets: ["blue", "elton"] });
console.log(merge({ name: "Colt" }, { num: 9 }));
merge<{ name: string }, { pets: string[] }>(
  { name: "colt" },
  { pets: ["blue", "elton"] }
);
```

### Generic Class Example

```ts
// A Generic Class Example
interface Song {
  title: string;
  artist: string;
}
interface Video {
  title: string;
  creator: string;
  resolution: string;
}

class Playlist<T> {
  public queue: T[] = [];
  add(el: T) {
    this.queue.push(el);
  }
}

const songs = new Playlist<Song>();
const videos = new Playlist<Video>();
```

---

## Null & Undefined

- **Null**
  - Intentional absence of any value.
- **undefined**
  - Variables that do not have an assigned values are undefined.

TypeScript has a powerful system to deal with `null` and `undefined`.

By default `null` and `undefined` handling is disabled, and can be enabled by setting **strictNullChecks** to true.

### Types

**null** and **undefined** are primitive types and can be used like other types, such as string.

```ts
let nullValue: string | undefined | null = null;
nullValue = "Hello";
nullValue = undefined;
console.log(nullValue);
```

When **strictNullChecks** is enabled, TypeScript requires values to be set unless undefined is explicitly added to the type.

### Nullish Coalescence

- Its a JS feature that also works well with TypeScript's null handling.
- It allows writing expressions that have a fallback specifically when dealing with `null` or `undefined`.
- This is helpful when other falsy values can occur in the expression but are still valid.
- It can be used with `??` operator in an expression.

**FYI**: _fallback means an 'alternative plan that may be used in an emergency'_.

```ts
function printMileage(mileage: number | undefined | null) {
  console.log(`Mileage: ${mileage ?? "Not Available"}`);
}

printMileage(null); // Mileage: Not Available

printMileage(undefined); // Mileage: Not Available

printMileage(12); //Mileage: 12
```

### Non-Null Assertion Operator

- A `!` post-fix expression operator may be used to assert that its operand is non-null and non-undefined in contexts where the type checker is unable to conclude that fact.
- Specifically the operation `x!` produces a value of the type `x` with `null` and `undefined`excluded.

```ts
function getValue(): string | undefined {
  return "hello";
}
let value = getValue();
console.log("value length: " + value!.length);
```

**Note** : Just like casting, this can be unsafe and should be used with care.

## Type Narrowing in Detail

- Narrowing the Type is simply doing a type check before working with a value.
- If your value is string you may want to use it differently than if you got a number.
- While dealing with
- Since unions allow multiple types for a value, it's good to check what came through before working with it.

In fact, optional types such as `x?: number` often require narrowing as well, as this typing is equivalent to `x: number | undefined`.

### Typeof Guards

**typeof** Type Guards involve simply doing a type check before working with a value.

```ts
function triple(x: string | number) {
  if (typeof x === "string") {
    return x.repeat(3);
  }
  return x * 3;
}
```

### Truthiness Guards

Truthiness Type Guards involve checking a value for being truthy or falsy before working with it.

```ts
const printLetters = (word: string | null }) => {
  if(!word){
    console.log("No Word Provided")
  }else{
    for(let char of word){
      console.log(char)
    }
  }
}
```

This is helpful in avoiding errors when values might be null or undefined.

### Equality Narrowing

**equality Type Guards** involve comparing types to each other before doing certain opearition with values.

By checking two values against one another, we can be sure they're both the same before working with them in a type-specific way

```ts
function someFunc(x: string | number, y: string | boolean) {
  if (x === y) {
    // x & y are string in these case
    console.log(x.toUpperCase);
    console.log(y.toUpperCase);
  } else {
    conosle.log(x);
    conosle.log(y);
  }
}
```

### in Operator Narrowing

**in** operator helps check if a certain property exists in an object.

This means we can use it to check if a value exists in an object, according to its type alias or aliases, before working with it

```ts
interface Movie {
  title: string;
  duration: number;
}

interface WebSeries {
  title: string;
  numEpisodes: number;
  episodeDuration: number;
}

function getRunTime(media: Movie | WebSeries) {
  if ("numEpisodes" in media) {
    return media.numEpisodes * media.episodeDuration;
  }
  return media.duration;
}

const horrorMovie: Movie = { title: "conjuring", duration: 180 };
console.log(getRunTime(horrorMovie)); //180
const thriller: WebSeries = {
  title: "Dark",
  numEpisodes: 24,
  episodeDuration: 60,
};
console.log(getRunTime(thriller)); //1440
```

### instanceof Narrowing

**insatanceof** is a operator that allows us to check if one thing is an instance of another.

```ts
function printFullDate(date: Date | String) {
  if (data instanceof Date) {
    return date.toUTCString();
  } else {
    return new Date(date).toUTCString();
  }
}
```

This can help us narrow types when working with thing like classes.

```ts
class User {
  constructor(public username: string) {}
}

class Company {
  constructor(public name: string) {}
}

function printName(entity: User | Company) {
  if (entity instanceof User) {
    return entity;
  } else {
    return entity;
  }
}

const john = new User("John");

console.log(printName(john));
```

### Type Predicates

TypeScript allows us to write custom functions that can narrow the type of a value.These functions have a very special return type called a type predicate.

A predicate takes the form **parameterName is type**, where parameterName must be the name of a parameter from the current function signature.

```ts
interface Cat {
  name: string;
  numLives: number;
}

interface Dog {
  name: string;
  breed: string;
}

function isCat(pet: Cat | Dog): pet is Cat {
  return (pet as Cat).numLives !== undefined;
}

function makeNoise(pet: Cat | Dog): string {
  if (isCat(pet)) {
    console.log(isCat(pet));
    return "meow";
  } else {
    console.log(pet);
    return "Woof";
  }
}

console.log(makeNoise({ name: "Blue", numLives: 3 }));
```

`pet is Cat` is out type pridicate in this example
Any time `isCat`is called with some variable, TypeScript will narrow that variable to that specific type if the original type is compatible.

### Descriminated Unions

A common pattern in Typescript involves creating a literal property that is common across multiple types.

We can then narrow the type using that literal property.

```ts
interface Pop {
  name: string;
  artist: string;
  kind: "pop";
}

interface EDM {
  name: string;
  artist: string;
  kind: "edm";
}

interface Rock {
  name: string;
  artist: string;
  kind: "rock";
}

type SongCategory = Pop | EDM | Rock;

function getDrumBeats(song: SongCategory) {
  switch (song.kind) {
    case "rock":
      return "Hard Rock Pattern";
    case "pop":
      return "8 Beat";
    case "edm":
      return "16 Beat";
  }
}

const numb: Rock = {
  name: "Numb",
  artist: "Linkin Park",
  kind: "rock",
};

console.log(getDrumBeats(numb));
```

Reference :<a href="https://basarat.gitbook.io/typescript/type-system/discriminated-unions">Discriminated Unions in Detail</a>

#### Exhaustiveness Checks with never

Quite commonly you want to make sure that all members of a union have some code(action) against them.

In below example, We had not written case for HipHop,

```ts
interface HipHop {
  name: string;
  artist: string;
  kind: "hiphop";
}

type SongCategory = Pop | EDM | Rock | HipHop;

function getDrumBeats(song: SongCategory) {
  switch (song.kind) {
    case "rock":
      return "Hard Rock Pattern";
    case "pop":
      return "8 Beat";
    case "edm":
      return "16 Beat";
    default:
      // We should never make it here, if we handled cases properly

      const exhaustiveCheck: never = song;
      return exhaustiveCheck;
  }
}
```

You can do that by simply adding a fall through and making sure that the inferred type in that block is compatible with the never type. For example if you add the exhaustive check you get a nice error:
**"Type 'HipHop' is not assignable to 'never' "**
This forces you to handle this new case

---

## Utility Types

TypeScript comes with a large number of types that can help with some common type manipulation,

### Partial

`Partial` changes all the properties in an object to be optional.

```ts
interface Point {
  x: number;
  y: number;
}

let pointPart: Partial<Point> = {}; // `Partial` allows x and y to be optional
pointPart.x = 10;
```

For More Utility types like **Required** , **Pick** amd more refer link:
<a href="https://www.w3schools.com/typescript/typescript_utility_types.php">Utility Types in TypesScript</a>
