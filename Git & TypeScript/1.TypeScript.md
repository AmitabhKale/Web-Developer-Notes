# TypeScript

TypeScript is a syntactic superset of JavaScript which adds static typing.

This basically means that TypeScript adds syntax on top of JavaScript, allowing developers to add types.

### Table of Contents

- [Setting Up TypeScript Compiler](#setting-up-typescript-compiler)
- [Debugging TypeScript Applications](#debugging-typescript-applications-with-vs-code)
- [Type Annotation Basic](#type-annotations-basics)
  - [Strings](#strings)
  - [Numbers](#numbers)
  - [Boolean](#booleans)
  - [Type Inference](#type-inference)
  - [Any](#any)
- [Functions](#function)
  - [Function Parameter Types](#function-parameter-types)
  - [Function Return Types](#function-return-types)
  - [Anonymous Functions](#anonymous-functions)
  - [Void](#void)
  - [Never](#never)
- [Objects](#objects)
  - [Type Alias](#type-alias)
  - [Nested Objects](#nested-objects)
  - [Optional Properties](#optional-properties)
  - [readonly Modifier](#readonly-modifier)
  - [InterSection Types](#intersection-types)
- [Arrays](#arrays)
  - [Multidimensional Array](#multimdemsional-array)
- [Union Types](#union-types)
  - [Type Narrowing](#type-narrowing)
  - [Union Type with Arrays](#union-type-with-arrays)
  - [Literal Types](#literal-types)
- [Tuples](#tuples)
- [Enums](#enums)
- [Interface](#interface)
- [Generics](#generics)
  - [Generics with arrow functions in tsx](#generics-in-arrow-functions--tsx-files)
  - [Generics with Constraint](#generics-with-constraints)

---

Reference: <a href="https://www.canva.com/design/DAFE2GNggKU/PVn7Jgvav6LeSalJj4R3OQ/view?utm_content=DAFE2GNggKU&utm_campaign=designshare&utm_medium=link2&utm_source=sharebutton#2">TypeScript Slides</a>

---

## Setting up TypeScript Compiler

TypeScript is transpiled into JavaScript using a compiler.
TypeScript has an official compiler which can be installed through npm.

```bash
npm install typescript --save-dev
```

The compiler is installed in the `node_modules` directory and can be run with: `npx tsc`.

```bash
npx tsc
```

### Configuring the Compiler

Reference: <a href="https://www.w3schools.com/typescript/typescript_getstarted.php">How to Configure the Compiler in TypeScript</a>

You can have TypeScript create tsconfig.json with the recommended settings with:

```baSh
npx tsc --init
```

Which should give you an output similar to:

```
target: es2016
  module: commonjs
  strict: true
  esModuleInterop: true
  skipLibCheck: true
  forceConsistentCasingInFileNames: true
```

Here is an example of more things you could add to the `tsconfig.json` file:

```
{
  "include": ["src"],
  "compilerOptions": {
    "outDir": "./build"
  }
}
```

You can open the file in an editor to add those options. This will configure the TypeScript compiler to transpile TypeScript files located in the `src/` directory of your project, into JavaScript files in the `build/` directory.

---

## Debugging TypeScript Applications with VS-Code

In `tsconfig.json` uncomment the `"sourceMap": true,` option in edit section.

```
    "sourceMap": true,
```

Now in vs-code go to left panel in Debug option

- Click on `create a launch.json file` which will create a `launch.json` file
- Add the below line in `configurations` array.

  ```json
    "preLaunchTask": "tsc: build - tsconfig.json",
  ```

- Put the breakpoint in left-gray area to debug
- Now Click on **Launch Program** in Debug Panel.

### Keyboard Shortcuts for Debugging

- `f5`: To Start the Debugging
- `f10`: Step Over --> Next line
- `f11`: Step Into --> For more defination

**Reference**: <a href="https://pkief.medium.com/how-to-debug-typescript-with-vs-code-9cec93b4ae56">Blog for Debugging TypeScript</a>

---

## Type Annotations Basics

#### Primitve Types

<table>
<tr>
<td style="color:orange">
 Number
 </td>
 <td style="color:orange">
Null
 </td>
 <td style="color:green">
Any
 </td>
</tr>

<tr>
<td style="color:orange">
String
 </td>
 <td style="color:orange">
Undefined
 </td>
 <td style="color:green">
Never
 </td>
</tr>
<tr>
<td style="color:orange">
Boolean
 </td>
 <td style="color:orange">
Void
 </td>
 <td style="color:green">
Unknown
 </td>
</tr>

</table>

#### Object Types

<table>
<tr>
<td style="color:orange">
Object
 </td>

 <td style="color:green">
Tuple
 </td>
</tr>
<tr>
<td style="color:orange">
Array
 </td>

 <td style="color:green">
Enum
 </td>
</tr>
<tr>
<td style="color:orange">
Function
 </td>

 <td style="color:green">
Others!
 </td>
</tr>
</table>

### Variable Types

Assigning a basic type to a variable is easy - just add **:Type** after the variable name!

(Also called **'Type Annotation'**)

**Syntax**: `let myVar: type = value`

```ts
// Desclaring a variable in js
const color = 'blue


// Declaring a variable in ts
const color: string = "blue";
```

### Strings

Strings represent character values like 'I Love TypeScript!'

We can tell TypeScript that something is a string using the type annotation of **string** (all lowercase)

```ts
// Declaring string
let myString: string = "Amazing Type System";

// Can't reassign to different type
myString = 100; // ❌

// Can reassign a value to the same Type
myString = "Changed"; //✔
```

### Numbers

Numbers can be typed with a simple Type Annotation of number (all lowercase)

```ts
// Declaring Number
let myNumber: number = 100;

// Can't reassign to different type
myNumber = "Cant Assinging String"; // ❌

// Can reassign a value to the same Type
myNumber = 25; //✔

// We can use underscore in large numbers for readbility.
let sales: number = 123_456_789;
```

### Booleans

Booleans can be typed with a simple type annotation of boolean (all lowercase)

```ts
const isAdmin: boolean = false;
```

### Type Inference

**Type Inference** refers to the Typescript compiler's ability to infer types from certain values in your code.

Typescript can remember a value's type even if you didn't provide a type annotation, and it will enforce that type moving forward.

```ts
// Creating a variable with a value, but without a type annotation
let x = 27;
x = "Twenty Seven";
// ERROR: Type 'String' is not assignable to type 'number'
```

### Any

**'any'** is an escape hatch! It turns off type checking for this variable so you can do your thing.

NOTE: it sort of defeats the purpose of TS and types, so use it sparingly!

```ts
// Declaring variable with any
let data = "Big Data";
// Can reassign to any type
data = 12; //✔
data = false; //✔
```

---

## Function

### Function Parameter Types

In TypeScript, we can specify the type of function parameters in a function defination.

This allows TypeScript to enforce the types for the value being passed into your function.

```ts
// Creating a func with typed args
function greet(name: string) {
  return `Hey ${name}, Welcome OnBoard!! `;
}

greet("John"); // --> Hey John, Welcome OnBoard

//❌ cant call this function with other type args
greet(23); // --> TypeScript error!!
```

### Function Return Types

We can specify the type returned by a function. Even though typescript can infer this

```ts
// Creating a function with return type
const addNums = (x: number, y: number): number => {
  return x + y;
};

addNums(5, 10); //  --> 15
```

### Anonymous Functions

When TypeScript infer how an unnamed function is going to be called, it can automatically infer its parametres' types.

```ts
const numbers = [1, 2, 3];

// Contextual typing on an Arrow function
numbers.forEach((num) => {
  return num.toUpperCase(); // Error: .toUpperCase() doesnt work for nums
});
```

### Void

Void is a return type for functions that dont return anything. It means just that this function is void on any data.

TypeScript can infer this type fairly well, but sometimes it may want you to annotate a function with a void return explicitly.

```ts
// A function that doesn't return anything
const annoyUser = (num: number): void => {
  for(let i=0; i<num ;i++>){
    alert('HiIIIII')
  }
}
```

### Never

The never type represents values that NEVER occur. We might use it to annotate a function that always throw an exception, or a function that never finishes executing.

Don't confuse with **void** -void returns undefined or null, which is technically still a type of value.With **never**, a function doesn't even finish executing.

```ts
// A function that doesn't finish executing
const neverStop = (): never => {
  while (true) {
    console.log("Program Running....");
  }
};

// A function that throws an exception
const giveError = (msg: string) => {
  throw new Error(msg);
};
```

---

## Objects

Objects can be typed by declaring what the object should look like in the annotation.

Accessing a property that isn't defined or performing operations without keeping types in min will throw errors!

```ts
// A function with object type Parameter
const printName = (name: { first: string; last: string }) => {
  return `Name: ${first} ${last}`;
};

printName({ first: "Will", last: "Ferrel" });
```

### Type Alias

Instead of writing out object types in an annotation, we can declare them seperately in a **type alias**, which is simply the desired shape of the object.

This allows us to make our code more readable and even reuse the type elsewhere in our code.

```ts
// A type Alias
type Person = {
  name: string;
  age: number;
};

// Use the Type Alias in the annotation
const sayHappyBirthday = (person: Person) => {
  return `Hey ${person.name}, Congrats on turning ${age}!`;
};

sayHappyBirthday({ name: "Jerry", age: 23 });
```

### Nested Objects

```ts
const describePerson = (person: {
  name: string,
  age: number,
  parentNames:{
    mom: string,
    dad: string
  }
}) => {
  return `Person: ${name}, Age: ${age} Parents:${parentNames.mom}, ${parentNames.dad} `,

}

describePerson({name:'john', age:23, parents: {mom:'Lana', dad:'Johnny'}})
```

#### Type Alias and Nested Object Example

```ts
// Type Alias and Nested Objects Example
type Song = {
  title: string;
  artist: string;
  numStreams: number;
  credits: { producer: string; writer: string };
};

function calculatePayout(song: Song): number {
  return song.numStreams * 0.0033;
}

function printSong(song: Song): void {
  console.log(`${song.title} - ${song.artist}`);
}

const mySong: Song = {
  title: "Stay",
  artist: "Justin Bieber",
  numStreams: 123_456_789,
  credits: {
    producer: "Justin Bieber",
    writer: "Charlie Puth",
  },
};

const earning = calculatePayout(mySong);
console.log(earning);
printSong(mySong);
```

#### Optional Properties

While declaring the type defination we can put optional Properties by putting `?`

```ts
//Optional Properties
type Point = {
  x: number;
  y: number;
  z?: number;
};

const myPoint: Point = { x: 1, y: 3 };
```

### readonly Modifier

if readonly check is there , we can't mutuate that data

```ts
type User = {
  readonly id: number;
  username: string;
};

const user: User = {
  id: 12837,
  username: "catgurl",
};

console.log(user.id);
user.id;
```

### Intersection Types

```ts
type Circle = {
  radius: number;
};

type Colorful = {
  color: string;
};

type ColorfulCircle = Circle & Colorful;

const happyFace: ColorfulCircle = {
  radius: 4,
  color: "yellow",
};
```

---

## Arrays

Arrays can be typed using a type annotation followed by empty array bracket, like **number[]** for an array of number.

Note: these array only allow data of that one type inside them.

```ts
// number array
let prices: number[] = [100, 200, 300];

// string array
let names: string[] = ["John", "Jane", "Sid"];

// Alternate Syntax
let names: Array<string> = ["Steve", "shirley"];
```

### Multimdemsional Array

```ts
const board: string[][] = [
  ["X", "O", "X"],
  ["X", "O", "X"],
  ["X", "O", "X"],
];
```

---

## Union Types

Union Types allow us to give a value of few different possible types.

We can create a union type by using the single | (pipe character) to seperate the types we want to include.

```ts
// Basic Union Type:
let age: number | string = 21;
age = 23;
age = "24";

// Union Type with Type Alias
type Point = {
  x: number;
  y: number;
};

type Loc = {
  lat: number;
  long: number;
};

let cordinates: Point | Loc = { x: 1, y: 34 };
coordinates = { lat: 321.213, long: 23.34 };
```

### Type Narrowing

Narrowing the Type is simply doing a type check before working with a value.If your value is string you may want to use it differently than if you got a number.

Since unions allow multiple types for a value, it's good to check what came through before working with it.

```ts
function calculateTax(price: number | string, tax: number) {
  if (typeof price === "string") {
    price = parseFloat(price.replace("$", ""));
  }
  return price * tax;
}
```

### Union Type with Arrays

```ts
type Point = {
  x: number;
  y: number;
};

type Loc = {
  lat: number;
  long: number;
};

const coords: (Point | Loc)[] = [];
coords.push({ lat: 321.213, long: 23.334 });
cords.push({ x: 213, y: 43 });
```

### Literal Types

Literal types are not just types - but the values themselves too!

On it's own, they may not seem useful, but combine them with unions and you can have very fine-tuned type options for Typescript to enforce.

```ts
let zero: 0 = 0;
let mood: "Happy" | "Sad" = "Happy";
mood = "Sad";
```

---

## Tuples

Tuples are a special type exclusive to TypeScript

Tuples are arrays of fixed lengths and ordered with specific types - like super rigid arrays.

```ts
const color: [number, number, number] = [255, 255, 255];

type HTTPResponse = [number, string];

const goodResponse = (HTTPResponse = [200, "OK"]);
```

---

## Enums

Enums allows us to define a **set of named constants**. We can give those constants numeric or string values.

```ts
enum STATUS {
  PENDING,
  SHIPPED,
  DELIVERED,
  RETURNED,
}
```

By default, enums will initialize the first value to `0` and add `1` to each additional vlaue.

Also You can set the value of the first numeric enum and have it auto increment from that (or) You can assign unique number values for each enum value. Then the values will not incremented automatically.

```ts
// Default Numeric Enums
enum Size {
  Small, // 0
  Medium, // 1
  Large, // 2
}

// Assigning first value in enum
enum Size {
  Small = 2
  Medium, // 3
  Large, // 4
}
```

Enums can also contain strings

```ts
// String Enums
enum CardinalDirections {
  North = "North",
  East = "East",
  South = "South",
  West = "West",
}
// logs "North"
console.log(CardinalDirections.North);
// logs "West"
console.log(CardinalDirections.West);
```

---

## Interface

Interfaces serve almost the exact same purpose as type aliases(with a slightly different syntax).

We can use them to create reusable, modular types that describes the **shapes of objects**

```ts
interface Person {
  readonly id: number;
  first: string;
  last: string;
  nickname?: string;
  // sayHi: () => string;
  sayHi(): string;
}

const thomas: Person = {
  first: "Thomas",
  last: "Hardy",
  nickname: "Tom",
  id: 21837,
  sayHi: () => {
    return "Hello!";
  },
};

thomas.first = "kasjdh";
```

```ts
interface Product {
  name: string;
  price: number;
  applyDiscount(discount: number): number;
}

const shoes: Product = {
  name: "Blue Suede Shoes",
  price: 100,
  applyDiscount(amount: number) {
    const newPrice = this.price * (1 - amount);
    this.price = newPrice;
    return this.price;
  },
};

console.log(shoes.applyDiscount(0.4));
```

#### Extending an Interface

The `extends` keyword on an interface allows us to effectively copy members from other named types, and add whatever new members we want.

```ts
// Re-opening an interface:
interface Dog {
  name: string;
  age: number;
}

interface Dog {
  breed: string;
  bark(): string;
}

const elton: Dog = {
  name: "Elton",
  age: 0.5,
  breed: "Australian Shepherd",
  bark() {
    return "WOOF WOOF!";
  },
};

// Extending an interface:
interface ServiceDog extends Dog {
  job: "drug sniffer" | "bomb" | "guide dog";
}

const chewy: ServiceDog = {
  name: "Chewy",
  age: 4.5,
  breed: "Lab",
  bark() {
    return "Bark!";
  },
  job: "guide dog",
};
```

```ts
interface Human {
  name: string;
}

interface Employee {
  readonly id: number;
  email: string;
}

// Extending multiple interfaces
interface Engineer extends Human, Employee {
  level: string;
  languages: string[];
}

const pierre: Engineer = {
  name: "Pierre",
  id: 123897,
  email: "pierre@gmail.com",
  level: "senior",
  languages: ["JS", "Python"],
};
```

## Generics

Generics allows us to define reusable functions and classes that work with multiple types rather than a single type.

```ts
function identity<Type>(arg: Type): Type {
  return arg;
}
```

In Below Example, function identity can take number as a input and return number,Same if we pass the string it will return string.

```ts
function identity<T>(id: T): T {
  return id;
}

console.log(identity<number>(123));
console.log(identity<string>("John"));
```

```ts
function getRandomElement<T>(list: T[]): T {
  const randIdx = Math.floor(Math.random() * list.length);
  return list[randIdx];
}

console.log(getRandomElement<string>(["a", "b", "c"]));
getRandomElement<number>([5, 6, 21, 354, 567, 234, 654]);
getRandomElement([1, 2, 3, 4]);
```

### Generics in Arrow Functions & .tsx files

While working with react, jsx may confuse with angle brackets.

```tsx
const CartItem = <T,>(item: T) => item;
```

Refernce: <a href="https://stackoverflow.com/questions/32308370/what-is-the-syntax-for-typescript-arrow-functions-with-generics">Stack Overflow Post about genrics in tsx</a>

### Genrics with Multiple Types

```ts
function merge<T, U>(obj1: T, obj2: U) {
  return {
    ...obj1,
    ...obj2,
  };
}

const comboObj = merge({ name: "John" }, { pets: ["blue"] });
console.log(comboObj);
```

### Generics with Constraints

```ts
// Generics With Constraints:
function merge<T extends object, U extends object>(object1: T, object2: U) {
  return {
    ...object1,
    ...object2,
  };
}

const comboObj = merge({ name: "colt" }, { pets: ["blue", "elton"] });
console.log(merge({ name: "Colt" }, { num: 9 }));
merge<{ name: string }, { pets: string[] }>(
  { name: "colt" },
  { pets: ["blue", "elton"] }
);
```

### Generic Class Example

```ts
// A Generic Class Example
interface Song {
  title: string;
  artist: string;
}
interface Video {
  title: string;
  creator: string;
  resolution: string;
}

class Playlist<T> {
  public queue: T[] = [];
  add(el: T) {
    this.queue.push(el);
  }
}

const songs = new Playlist<Song>();
const videos = new Playlist<Video>();
```
