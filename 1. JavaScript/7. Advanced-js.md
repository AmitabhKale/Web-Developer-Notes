# Advanced Topics in JavaScript for Working with Frameworks

- [Redux PreRequisites to know](#redux-prerequisites-to-know)
- [Pure Functions](#pure-functions)
- [Immutablity](#immutability)
- [Updating patterns for objects](#updating-pattern-for-objects-object-mutation)
- [Updating patterns for Arrays](#updating-pattern-for-arrays)

---

# REDUX PREREQUISITES TO KNOW

## Pure Functions

- A Pure Function is a function (a block of code) that always returns the same result if the same arguments are passed.
- It does not depend on any state or data change during a program’s execution. Rather, it only depends on its input arguments.
- Also, a pure function does not produce any observable side effects such as network requests or data mutation, etc.

```js
function isEligibele(age, minAge) {
  return age > minAge;
}

console.log(isEligibele(19, 16));
```

#### Benifits

- Self-documenting
- Easily Testable
- Concurreny
- Cacheable

---

## Immutability

- An immutable value is one whose content cannot be changed without creating an entirely new value.
- In JavaScript, **primitive values** (string, numbers etc) are immutable — once a primitive value is created, it cannot be changed, although the variable that holds it may be reassigned another value.
- By contrast, objects and arrays are mutable by default — their properties and elements can be changed without reassigning a new value.

<table>
<tr>
<th>Pros</th>
<th>Cons</th>
 </tr>
 <tr>
 <td>Predictability</td>
 <td>Performance</td>
  </tr>
 <tr>
 <td>Faster Change Detection</td>
 <td>Memory Overhead</td>
   <tr>
 <td>Concurrency</td>
   </tr>
 </tr>
</table>

---

## Updating Pattern for Objects (Object Mutation)

There are many third party libraries available which we can use to prevent object mutation. we are going to deal with 2 JavaScript techniques

### 1. Object.assign()

- This method tried to copy all parameters from source object to destination object.This method can give mutable object as output if not used properly.
- It’s easy to avoid mutating objects by providing an empty object in the target parameter.

- syntax: `Object.assign(target, ...sources)`

Example:

```js
const person = { name: "John" };

const updated = Object.assign({}, person, { name: "Steve" });

console.log(updated); // {name: 'Steve'}
```

Properties in the target object are overwritten by properties in the sources if they have the same key.

### 2. Using Spread Operators

spread syntax can be used to prevent object mutation.

```js
const person = { name: "John" };

const updated = { ...person, name: "Jack" };

console.log(updated); // {name: 'Jack'}
```

**Note:** The spread operator makes deep copies of data if the data is not nested.

```js
const person = {
  name: "John",
  address: {
    city: "Mumbai",
  },
};

const updated = { ...person, name: "Jack" };
updated.address.city = "Nagpur";

console.log(person);
```

- When you have nested data in an array or object the spread operator will create a deep copy of the top most data and a shallow copy of the nested data.
- As you can see in output below while `console.log(person)` obj we got the modified address i.e `address.city ="Nagpur"`
- This is because, When you copy any object it take reference of original object which means copied object is pointing to the original object and that’s the reason it was updating the original object.

```js
// OUTPUT:
{
    name: 'John',
    address: {  city: 'Nagpur'  }
}
```

To Solve above problem, we need to make deep copy

```js
const person = {
  name: "John",
  address: {
    city: "Mumbai",
    country: "India",
  },
};

const updated = {
  ...person,
  address: {
    ...person.address,
    city: "Nagpur",
  },
};

console.log(person);
```

As you can see now we get same result

```js
// OUTPUT:
{
    name: 'John',
    address: {  city: 'Mumbai'  }
}
```

#### Glance about Deep copy & shallow copy

- A **deep copy** means the data saved to a variable is in fact independent of the original data
- a **shallow copy** means the data is still in someway connected to the original variable

---

## Updating Pattern for Arrays

Generally we use these techniques in react which are kind of known as ** Immutable Update Patterns**

#### Adding

```js
const numbers = [1, 2, 3];

const added = [4, ...numbers];

console.log(added); // [4,1,2,3]
```

#### Removing

```js
const numbers = [1, 2, 3];

const removed = numbers.filter((x) => x !== 2);

console.log(removed); // [1,3]
```

#### Updating

```js
const numbers = [1, 2, 3];

const updated = numbers.map((num) => (num === 2 ? 20 : num));

console.log(updated); // [1,20,3]
```

---

## Enforcing Immuability

- Immutable (Created by Facebook)
- Immer (created by mobX)
- Mori
